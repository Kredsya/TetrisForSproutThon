테트리스

1. 블럭의 데이터가 저장되는 곳
	가. 플레이 공간
		- 블럭이 쌓이고, 내려오고 하는 등 플레이의 중심이 되는 곳에 있는 블럭.
		1) 떨어지고 있는 블럭
		2) 이미 쌓여있는 블럭
	나. Next
		- 다음에 어떤 블럭이 나올 지 보여주는 공간
		1) 5개의 미리보기 블럭
	다. Hold (홀드)
		- 블럭이 임시로 홀드되는 공간
		1) 홀드되어 있는 블럭

2. 7-bag에 맞춰 블록들이 나온다.
	- 7-bag이란? : 7개의 블록이 한 사이클을 이루어서 나오는 시스템. 7개 단위로 끊어서 블럭을 쌓으면 겹치는 블럭이 없다.
	- 구현 방법
		- 크기 14의 vector를 만들고 두 사이클(7개 x 2)의 블럭을 채운다.
		- 한 사이클의 블럭을 사용할 때마다 새로운 한 사이클의 블럭을 push_back한다.	//블럭 미리보기를 5개로 생각하고 있습니다.
		- Hard Drop 또는 자연 Drop으로 인해 블럭이 놓였다고 판단되면 "떨어지고 있는 블럭" 자리에 vector.front()를 넣고, vector.erase(vector.begin())한다.
	
	- 배운 내용 관련 점수 딸 가능성 : {4번}에서 vector를 사용할 것 같은데, 그렇기에 {2번}은 queue로 구현하면 다양한 자료구조를 사용했다고 어필할 수 있음.

3. 미리보기가 5개 있다.
	- 구현 방법
		- 2번과 연관된 내용. 3번에서는 구체적으로 어떻게 표현할 지를 다룸.
		- 각 블럭마다 가로4, 세로2의 공간을 가진다.
		- O블럭을 제외한 블럭들은 Left-Up 정렬한다.
		- 예시1) L 블럭
			■□□□
			■■■□
		- 예시2) O 블럭
			□■■□
			□■■□
		- 각각의 블럭이 차지하는 공간은 한 칸을 사이에 두고 떨어져 있다. 또한 세로로 5개가 세워져 있다.
		- 미리보기로 표시되는 블럭들은 vector[0]부터 vector[4]까지에 저장된 블럭 데이터를 참고해 출력하면 된다.

4. 줄이 채워지면 지워진다.
	- 한 줄부터 네 줄까지 동시에 지워질 수 있다.
	- 맵 컨테이너 : 크기 24(가로줄의 개수 20줄)의 vector<pair<vector<bool>, int>>로 사용한다. vector<bool>는 크기10의 벡터로 블록이 어떻게 쌓여있는지를(가로줄 크기), 뒤의 int는 해당 가로줄에 있는 네모박스의 개수를 저장한다.
	- 가장 밑의 줄의 y좌표는 0이다. 위로 올라갈 수록 y좌표가 높아지며, 최대는 23이다. (23인 이유는 화면에 보이는 최대 y좌표인 19에 더해서 {6번 게임 오버 판정}에 여유 공간 4칸이 필요하기 때문)
	- Hard Drop 또는 자연 Drop으로 인해 블럭이 놓였다고 판단될 때 4번 동작을 수행하는 함수를 호출한다.
	- 구현 방법
		- 방금 위에서 말한 것처럼 함수가 호출된다.
		- 해당 블럭이 놓인 line에 해당하는 vector의 pair<vector<bool>, int>를 갱신시킨다.
		- int가 10이 되면 해당 줄은 꽉 찼다는 이야기이므로 다음을 수행한다.
			- (i는 0부터 시작) i번째 줄이 꽉 차서 지워야 한다고 가정한다.
			- vector[i].erase(vector.begin()+i) 를 통해 해당 줄의 네모박스 정보와 네모박스의 개수에 대한 데이터를 한 번에 지울 수 있다.
			- push_back을 지워진 줄 수만큼 수행하면 비어있는 줄이 맨 위에 다시 쌓일 것이다.

5. 특정 시간마다 블럭이 한 칸 씩 떨어진다.
	- Thread(쓰레드)를 통해 구현할 수 있음. https://modoocode.com/269
	- 쓰레드란? : 쉽게 말해 함수 여러개를 동시에 실행하고 싶을 때 사용하는 개념.
	- 어떻게 도와줄 것인가? : 예를들어 1초마다 블럭이 자동으로 내려오게 하고 싶으면 다음 함수를 만들어서 실행시켜 놓으면 됨.
		void goBlockDown() {
			while(true) {
				//블럭을 한 칸 아래로 내리는 명령어 묶음
				Sleep(1000);
				//블럭 판정 분기문
			}
		}
		이 함수를 쓰레드에 등록해서 항상 작동시켜두면 됨. (위 코드는 예시이며 달라질 수 있음)
	- 이걸 통해 연속해서 특정 횟수만큼 블럭에 막혀 아래로 움직이지 못했다면 자연 Drop으로 처리할 수도 있음. (ex. 연속 3번 아래로 내려갈 수 없었음(3초 동안 바닥에 붙어있었음) -> 자연 Drop 판정)

6. 게임 오버 판정
	- 블럭이 쌓임 판정 당시 블럭의 네모박스들 중 y좌표가 19를 넘어서면(화면 밖을 넘어간 네모박스가 있다면) 게임오버 판정.
	- 오리지널의 경우 : 블럭이 생성될 공간에 블럭이 있을때만 게임오버 판정. 즉, 화면 밖을 넘어가도 y좌표 19의 가운데 4칸에만 네모박스가 없다면 게임오버 판정이 아님. 이 경우 y좌표는 최대 40까지 확장시켜야 함.

7. 블럭을 돌릴 수 있어야 한다.
	- SRS 시스템 https://harddrop.com/wiki/SRS
	- SRS(Super Rotation System)이란? : 블럭을 돌리는데 있어서 막히는 블록이 있을 경우, 어떻게 막혀있냐에 따라 블럭의 위치를 정해진 표에 따라 움직일 수 있게끔 만들어 놓은 시스템
	- SRS 덕분에 보통은 들어갈 수 없는 곳도 넣을 수 있다.
	- 자세한 설명은 구두로 진행. (조금 복잡)
	- 시간이 되면 구현하는 거로 결정남.

8. 홀드
	- 처음은 비어있다.
	- 홀드 키를 누르면 현재 떨어지고 있는 블럭과 홀드 블럭을 서로 바꾼다. 만약 홀드해놓은 블럭이 없다면 홀드에 현재 블럭이 들어가고 다음 블럭이 떨어지기 시작한다.
	- 보통 왼쪽 위에 홀드 블럭을 보여준다. 보여주는 형식은 {3번}과 동일하다. 다른 점은 홀드 블럭은 하나라는 점.